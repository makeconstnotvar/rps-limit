# План по реализации уникальных визуализаций алгоритмов rate limiting в rps-limit

## Общие действия

1. Удалить или переписать `VisualizerWrapper`.
2. Создать папку `/src/illustrations`, в ней по одному компоненту на каждый алгоритм.
3. Подключить визуализации к общему селектору алгоритма (`LimiterVisualizerSwitch`).
4. Все визуализации используют canvas или SVG.
5. Источник запросов — сигнал с текущей частотой, задаваемой пользователем.

---

## Fixed Window

### Визуальная метафора
Контейнер, принимающий до N шариков (запросов) в фиксированном интервале.

### Шаги реализации
- Нарисовать прямоугольник — текущее окно.
- Отображать число принятых запросов в этом окне.
- Шарики падают сверху. Пока лимит не достигнут — попадают в контейнер.
- После достижения лимита — отскакивают.
- Каждые T секунд окно сбрасывается (анимация стирания/обнуления).

---

## Sliding Log

### Визуальная метафора
Временная шкала с метками (логами) запросов.

### Шаги реализации
- Нарисовать горизонтальную временную шкалу на T секунд.
- Каждый принятый запрос — метка/точка на шкале.
- Перед добавлением нового — проверка количества точек в окне.
- Если превышает лимит — шарик отскакивает.
- Удаление меток при выходе за окно.
- Плавное движение шкалы влево, как бегущая лента.

---

## Sliding Window Counter

### Визуальная метафора
Два перекрывающихся окна (текущее и предыдущее), расчёт веса.

### Шаги реализации
- Нарисовать две полупрозрачные полосы с перекрытием (предыдущее и текущее окно).
- Подписи: сколько запросов в каждом.
- Коэффициент пропускной способности = сумма взвешенных значений.
- Шарик добавляется, если сумма < лимита.
- При отклонении — визуальное мигание.

---

## Token Bucket

### Визуальная метафора
Ведро с токенами. Каждый запрос забирает токен.

### Шаги реализации
- Нарисовать ведро (контейнер) с токенами в виде кругов.
- Пополнение токенов по таймеру (анимация сверху вниз).
- Шарик падает — если токен есть, он исчезает, запрос проходит.
- Если токенов нет — шарик отклоняется.
- Ограничить максимум токенов.

---

## Leaky Bucket

### Визуальная метафора
Очередь, из которой запросы "утекают" с фиксированной скоростью.

### Шаги реализации
- Нарисовать вертикальный контейнер-очередь (FIFO).
- Шарики поступают внутрь, вытекают снизу с фиксированной скоростью.
- Если очередь переполнена — входящий шарик отклоняется.
- Утечка — регулярная анимация снизу вверх.

---

## Интеграция

- Все алгоритмы получают поток входящих запросов и параметры через props.
- Унифицированный интерфейс типа:
  ```ts
  interface RateLimiterIllustrationProps {
    requests$: Signal<RequestEvent>; // запросы во времени
    config: AlgorithmConfig;
  }
